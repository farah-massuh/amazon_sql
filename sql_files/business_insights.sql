-- Business Questions

/*----------
1. Top Selling Products
Query the top 10 products by total sales value.
Get the product name, total quantities sold, and total sales value.
----------*/
-- creating a new column named total_sale
ALTER TABLE order_items
ADD COLUMN total_sale FLOAT;
-- updating total_sale with quantity * price_per_unit
UPDATE order_items
SET total_sale = quantity * price_per_unit;
-- query
SELECT
    oi.product_id,
    p.product_name,
    ROUND(SUM(total_sale)) AS total_sale,
    COUNT(o.order_id) AS total_orders
FROM orders o
JOIN order_items oi ON oi.order_id = o.order_id
JOIN products p ON p.product_id = oi.product_id
GROUP BY 1, 2
ORDER BY 3 DESC
LIMIT 10;



/*----------
2. Revenue by Category
Calculate total revenue generated by each product category.
Inlcude the percentage contribution of each category to total revenue.
----------*/
SELECT
    p.category_id,
    c.category_name,
    ROUND(SUM(oi.total_sale)) AS total_sale,
    ROUND((SUM(oi.total_sale::NUMERIC) * 100 -- NUMERIC to get decimals
        / (SELECT SUM(total_sale::NUMERIC) FROM order_items)), 2) AS percentage_contribution
FROM order_items oi
JOIN products p ON p.product_id = oi.product_id
LEFT JOIN category c ON c.category_id = p.category_id
GROUP BY 1, 2
ORDER BY 3 DESC;



/*----------
3. Average Order Value (AOV)
Compute the average order value for each customer.
Include only customers with more than 5 orders.
----------*/
SELECT
    co.customer_id,
    CONCAT(co.first_name, ' ', co.last_name) AS full_name,
    COUNT(o.order_id) AS total_orders,
    ROUND(SUM(oi.total_sale::NUMERIC) / COUNT(o.order_id),2) AS average_order_value
FROM customers co
JOIN orders o ON o.customer_id = co.customer_id
JOIN order_items oi ON oi.order_id= o.order_id
GROUP BY 1
HAVING COUNT(o.order_id) > 5
ORDER BY 4 DESC;



/*----------
4. Monthly Sales Trend
Query monthly total sales over the past year.
Display the sales trend, grouping by month, return current month sale, and last month sale.
----------*/
WITH month_total_sales_past_year AS (
    SELECT
        EXTRACT(MONTH FROM o.order_date) AS month,
        EXTRACT(YEAR From o.order_date) AS year,
        ROUND(SUM(oi.total_sale::NUMERIC), 2) AS total_sale
    FROM orders as o
    JOIN order_items AS oi ON oi.order_id = o.order_id
    WHERE o.order_date >= CURRENT_DATE - INTERVAL '1 year'
    GROUP BY 1, 2
    ORDER BY 
        year,
        month
)
-- compare current month sales with last month
SELECT
    year,
    month,
    total_sale AS current_month_sale,
    -- retrieves the previous row's value (if no value, then NULL)
    LAG(total_sale, 1) OVER (ORDER BY year, month) AS last_month_sale
FROM month_total_sales_past_year;



/*----------
5. Customers with No Purchases
Find customers who have registered but never placed an order.
----------*/
SELECT * 
FROM customers
WHERE customer_id NOT IN (
    SELECT DISTINCT customer_id
    FROM orders
);



/*----------
6. Best-Selling categories by State
Identify the best-selling product category for each state.
Include the total sales for that category within each state.
----------*/
WITH ranked_sales AS (
    SELECT
        c.state,
        cat.category_name,
        SUM(oi.total_sale) AS total_sale,
        -- partitions by state, orders by the sum of the total sale, and then gets the rank for the entire data
        RANK() OVER(PARTITION BY c.state ORDER BY SUM(oi.total_sale) DESC) AS rank
    FROM orders o
    JOIN customers c ON o.customer_id = c.customer_id
    JOIN order_items oi ON o.order_id = oi.order_id
    JOIN products p ON oi.product_id = p.product_id
    JOIN category cat ON cat.category_id = p.category_id
    GROUP BY 
        c.state, 
        cat.category_name
)
SELECT 
    state, 
    category_name, 
    ROUND(total_sale::NUMERIC, 2) as total_sale
FROM ranked_sales
WHERE rank = 1
ORDER BY 
    state, 
    total_sale DESC;



/*----------
7. Customer Lifetime Value (CLTV)
Calculate the total value of orders placed by each customer over their lifetime.
Rank customers based on their CLTV.
----------*/
SELECT
    c.customer_id,
    CONCAT(c.first_name, ' ', c.last_name) AS full_name,
    ROUND(SUM(oi.total_sale::NUMERIC),2) AS CLTV,
    -- tied values get the same rank and no gaps in rank numbers
    DENSE_RANK() OVER (ORDER BY SUM(oi.total_sale) DESC) AS customer_ranking
FROM orders o
JOIN customers c ON c.customer_id = o.customer_id
JOIN order_items oi ON oi.order_id = o.order_id
GROUP BY 
    c.customer_id, 
    full_name;



/*----------
8. Inventory Stock Alerts
Query products with stock levels below a certain threshold (e.g., less than 10 units).
Include last restock date and warehouse information.
----------*/
SELECT
    i.inventory_id,
    p.product_name,
    i.stock AS current_stock_left,
    i.last_stock_date,
    i.warehouse_id
FROM inventory i
JOIN products p ON p.product_id = i.product_id
WHERE i.stock < 10;



/*----------
9. Shipping Delays
Identify orders where the shipping date is later than 2 days after the order date.
Include customer, order details, and delivery provider.
----------*/
SELECT
    CONCAT(c.first_name, ' ', c.last_name) AS customer,
    o.*,
    s.shipping_providers,
    (s.shipping_date - o.order_date) AS days_to_deliver
FROM orders o
JOIN customers c ON c.customer_id = o.customer_id
JOIN shippings s ON o.order_id = s.order_id
WHERE s.shipping_date - o.order_date > 2;



/*----------
10. Payment Success Rate
Calculate the percentage of successful payments across all orders.
Include breakdowns by payment status (e.g., failed pending).
----------*/
SELECT
    p.payment_status,
    COUNT(*) AS total_payments,
    ROUND(COUNT(*) * 100 / SUM(COUNT(*)) OVER(), 2) AS percentage
FROM orders o
JOIN payments p ON o.order_id = p.order_id
GROUP BY 1
ORDER BY 3 DESC;



/*----------
11. Top Perfomring Sellers
Find the top 5 sellers based on total sales value.
Include both successful and failed orders, and display their percentage of successful orders.
----------*/ 
-- find top 5 sellers based on total sales value
WITH top_sellers AS (
    SELECT
        s.seller_id,
        s.seller_name,
        SUM(oi.total_sale) AS total_sale
    FROM orders o
    JOIN sellers s ON o.seller_id = s.seller_id
    JOIN order_items oi ON oi.order_id = o.order_id
    GROUP BY 1, 2
    ORDER BY 3 DESC
    LIMIT 5
),
-- find the total of each order status for each seller
sellers_order_status AS (
    SELECT
        seller_id,
        order_status,
        COUNT(*) AS total_orders
    FROM orders
    GROUP BY 1, 2
),
-- filter out orders that are inprogress or returned
sellers_report AS (
    SELECT
        ts.seller_id AS seller_id,
        ts.seller_name AS seller_name,
        sos.order_status AS order_status,
        sos.total_orders AS total_orders
    FROM sellers_order_status sos
    JOIN top_sellers ts ON ts.seller_id = sos.seller_id
    WHERE sos.order_status NOT IN ('Inprogress', 'Returned')
    ORDER BY 1
)
-- display completed, failed, total, successful percentage, and failed percentage
SELECT
    seller_id,
    seller_name,
    SUM(CASE WHEN order_status = 'Completed' THEN total_orders ELSE 0 END) AS completed_orders,
    SUM(CASE WHEN order_status = 'Cancelled' THEN total_orders ELSE 0 END) AS failed_orders,
    SUM(total_orders) AS total_orders,
    ROUND(SUM(CASE WHEN order_status = 'Completed' THEN total_orders ELSE 0 END)::NUMERIC / SUM(total_orders)::NUMERIC * 100, 2) AS successful_orders_percentage,
    ROUND(100 - (SUM(CASE WHEN order_status = 'Completed' THEN total_orders ELSE 0 END)::NUMERIC / SUM(total_orders)::NUMERIC * 100), 2) AS failed_orders_percentage
FROM sellers_report
GROUP BY 1, 2



/*----------
12. Product Profit Margin
Calculate the profit margin for each product (difference between price and cost of goods sold)
Rank products by their profit margin, showing highest to lowest.
----------*/
SELECT
    product_id,
    product_name,
    profit_margin,
    DENSE_RANK () OVER(ORDER BY profit_margin DESC) AS product_ranking
FROM (
    SELECT
        p.product_id,
        p.product_name,
        SUM(total_sale - (cogs * quantity)) / SUM(total_sale) * 100 AS profit_margin
    FROM order_items oi
    JOIN products p ON oi.product_id = p.product_id
    GROUP BY 1, 2
)



/*----------
13. Most Returned Products
Query the top 10 products by the number of returns
Display the return rate as a percentage of total units sold for each product.
----------*/
SELECT
    *,
    ROUND(total_returned::NUMERIC / total_units_sold::NUMERIC * 100, 2) return_percentage
FROM (
    SELECT
        p.product_id,
        p.product_name,
        COUNT(*) total_units_sold,
        SUM(CASE WHEN o.order_status = 'Returned' THEN 1 ELSE 0 END) total_returned
    FROM order_items oi
    JOIN products p ON oi.product_id = p.product_id
    JOIN orders o ON o.order_id = oi.order_id
    GROUP BY 1, 2
)
ORDER BY return_percentage DESC
LIMIT 10;



/*----------
14. Identify customers either returning or new
If the customer has done more than 5 returns categorize them as returning, otherwise, new
List name, total orders, and total returns.
----------*/
SELECT
    *,
    CASE WHEN total_returns > 5 THEN 'Returning' ELSE 'New' END customer_type
FROM (
    SELECT
        CONCAT(c.first_name, ' ', c.last_name) full_name,
        COUNT(o.order_id) total_orders,
        SUM(CASE WHEN o.order_status = 'Returned' THEN 1 ELSE 0 END) total_returns
    FROM orders o
    JOIN customers c ON c.customer_id = o.customer_id
    JOIN order_items oi ON oi.order_id = o.order_id
    GROUP BY 1
)



/*----------
15. Top 5 Customers by orders in Each state
Identify the top 5 customers with the highest number of orders for each state.
Include the number of orders and total sales for each customer.
----------*/
SELECT *
FROM (
    SELECT
        c.state,
        CONCAT(c.first_name, ' ', c.last_name) customers,
        COUNT(o.order_id) total_orders,
        SUM(oi.total_sale) total_sale,
        DENSE_RANK() OVER(PARTITION BY c.state ORDER BY COUNT(o.order_id) DESC) as rank
    FROM orders o
    JOIN order_items oi ON oi.order_id = o.order_id
    JOIN customers c ON c.customer_id = o.customer_id
    GROUP BY 1, 2
    ORDER BY 1
)
WHERE rank <= 5;



/*----------
16. Revenue by Shipping Provider
Calculate the total revenue handled by each shipping provider.
Include the total number of orders handled and the average delivery time for each provider.
----------*/
SELECT
    s.shipping_providers,
    COUNT(o.order_id) orders_handled,
    ROUND(SUM(oi.total_sale)) total_sale,
    ROUND(COALESCE(AVG(s.return_date - s.shipping_date), 0)) as average_days
FROM orders o
JOIN order_items oi ON oi.order_id = o.order_id
JOIN shippings s ON s.order_id = o.order_id
GROUP BY 1



/*----------
17. Top 10 products with highest decreasing revenue ratio compared to 2023 and 2024.
Return product id, product name, category name, 2023 revenue and 2024 revenue decrease ratio at end.
Note: Decrease ratio = (current_year - last_year / last_year) * 100
----------*/
-- query for 2023
WITH last_year_sale AS (
    SELECT
        p.product_id,
        p.product_name,
        SUM(oi.total_sale) revenue
    FROM orders o
    JOIN order_items oi ON oi.order_id = o.order_id
    JOIN products p ON p.product_id = oi.product_id
    WHERE EXTRACT(YEAR FROM o.order_date) = 2023
    GROUP BY 1, 2
),
-- query for 2024
current_year_sale AS (
    SELECT
        p.product_id,
        p.product_name,
        SUM(oi.total_sale) revenue
    FROM orders o
    JOIN order_items oi ON oi.order_id = o.order_id
    JOIN products p ON p.product_id = oi.product_id
    WHERE EXTRACT(YEAR FROM o.order_date) = 2024
    GROUP BY 1, 2   
)
-- overall query
SELECT
    cs.product_id,
    cs.product_name,
    ls.revenue last_year_revenue,
    cs.revenue current_year_revenue,
    ls.revenue - cs.revenue rev_difference,
    ROUND((cs.revenue - ls.revenue)::NUMERIC / ls.revenue::NUMERIC * 100, 2) revenue_decrease_ratio
FROM last_year_sale ls
JOIN current_year_sale cs ON ls.product_id = cs.product_id
WHERE ls.revenue > cs.revenue
ORDER BY 6 DESC
LIMIT 10;






/*----------
Final Task -- Store Procedure
Create a function as soon as the product is sold.
The same quantity should be reduced from the inventory table.
After adding any sales records it should update the stock in the inventory table based on the product and quantity purchased.
----------*/
CREATE OR REPLACE PROCEDURE add_sales
(
    p_order_id INT,
    p_customer_id INT,
    p_seller_id INT,
    p_order_item_id INT,
    p_product_id INT,
    p_quantity INT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_count INT;
    v_price FLOAT;
    v_product_name VARCHAR(50);
BEGIN
    -- Get price and product name based on product_id
    SELECT 
        price, product_name  -- corrected from 'price_name' to 'product_name'
    INTO v_price, v_product_name
    FROM products
    WHERE product_id = p_product_id;

    -- Check inventory stock
    SELECT COUNT(*)
    INTO v_count
    FROM inventory
    WHERE product_id = p_product_id AND stock >= p_quantity;

    IF v_count > 0 THEN
        -- Insert into orders
        INSERT INTO orders (
            order_id,
            order_date,
            customer_id,
            seller_id
        )
        VALUES (
            p_order_id,
            CURRENT_DATE,
            p_customer_id,
            p_seller_id
        );

        -- Insert into order_items
        INSERT INTO order_items (
            order_item_id,
            order_id,
            product_id,
            quantity,
            price_per_unit,
            total_sale
        )
        VALUES (
            p_order_item_id,
            p_order_id,
            p_product_id,
            p_quantity,
            v_price,
            v_price * p_quantity
        );

        -- Update inventory
        UPDATE inventory
        SET stock = stock - p_quantity
        WHERE product_id = p_product_id;

        RAISE NOTICE 'Thank you, product "%" has been added and inventory updated.', v_product_name;
    ELSE
        RAISE NOTICE 'Product "%" is not available at the moment.', v_product_name;
    END IF;
END;
$$;

-- IMPLEMENTING FUNCTION
-- Reference
-- (
--     p_order_id INT,
--     p_customer_id INT,
--     p_seller_id INT,
--     p_order_item_id INT,
--     p_product_id INT,
--     p_quantity INT
-- )

-- TESTING --

-- first call
call add_sales
(
    25001, 2, 5, 26001, 1, 10
);
-- display result
SELECT
    product_id,
    stock
FROM inventory
WHERE product_id = 1;

-- second call
call add_sales
(
    25002, 2, 5, 26002, 1, 12
);
-- display result
SELECT
    product_id,
    stock
FROM inventory
WHERE product_id = 1;

-- third call
call add_sales
(
    25003, 2, 5, 26003, 1, 3
);
-- display result
SELECT
    product_id,
    stock
FROM inventory
WHERE product_id = 1;

-- fourth call
call add_sales
(
    25004, 2, 5, 26004, 1, 40
);
-- display result
SELECT *
FROM inventory
WHERE product_id = 1;

